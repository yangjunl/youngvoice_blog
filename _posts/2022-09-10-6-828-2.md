---
title: 6.828 JOS lab2
description: mit 6.828 lab2
categories:
 - operating system
 - JOS series
tags: [learning]
---


# What components the memory management to operate?
1. physical memory allocator 
2. the maps of virtual memory to physical memory




The x86 hardware's memory management unit (MMU) performs the mapping when instructions use memory
什么时候的内存访问不会经过 MMU 的管理？？？(dma ... ?)


# 在运行到 page_free_list list 被创建好之前，boot_alloc调用期间，整个内存空间是什么状态？
boot_alloc 分配的是哪些空间里的内存？
用来创建 page_free_list 的内存页是在哪些空间里？


该状态就是在 entry_pgdir 中指定的映射状态

| physical memory | virtual memory | comments |
|-----------------|----------------|--------|
| [0, 4MB)| [0, 4MB) | this region is critical for a few instructions in entry.S and we never use it again|
| [0, 4MB) | [KERNBASE, KERNBASE+4MB) | We choose 4MB because that's how much we can map with one page table and it's enough to get us through early boot |

当调用 i386_init() 函数时，代码已经跑在了 [KERNBASE, KERNBASE+4MB) 的高地址空间里面。


inc/memlayout.h
kern/pmap.h
inc/mmu.h

boot_alloc 的实现

```c
static void *
boot_alloc(uint32_t n)
{
        static char *nextfree;  // virtual address of next byte of free memory
        char *result;

        // Initialize nextfree if this is the first time.
        // 'end' is a magic symbol automatically generated by the linker,
        // which points to the end of the kernel's bss segment:
        // the first virtual address that the linker did *not* assign
        // to any kernel code or global variables.
        if (!nextfree) {
                extern char end[];
                nextfree = ROUNDUP((char *) end, PGSIZE);
        }

        // Allocate a chunk large enough to hold 'n' bytes, then update
        // nextfree.  Make sure nextfree is kept aligned
        // to a multiple of PGSIZE.
        //
        // LAB 2: Your code here.
        if (n > 0) {
                result = nextfree;
                nextfree += n;
                nextfree = ROUNDUP((char *) nextfree, PGSIZE);
                return result;
        }
        else // n == 0
        {
                result = ROUNDUP((char *) nextfree, PGSIZE);
                return result;
        }

        return NULL;
}

```

值得注意的是 boot_alloc 操作的是内核的虚拟地址。


Rounding operation

对 page_init 的说明，注释已经说得比较明白，就实现细节上如何找到已有特殊用途的页，和已被内核占用的页是值得思考的问题。

在代码里没有找到对 page_free_list 的初始化，但是该变量是全局变量并且没有被初始化，好像不会影响功能的正确性？??

todo
page_init 如何初始化相关页的 pp_ref count ?
回答该问题的关键是找到判定空闲页的条件，是在空闲链表上，还是 pp_ref = 0


```c

// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------

//
// Initialize page structure and memory free list.
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//

void
page_init(void)
{
        size_t npages_hole = (EXTPHYSMEM - IOPHYSMEM) / PGSIZE;
        uint32_t temp1 = (uint32_t)boot_alloc(0);
        uint32_t temp2 = (uint32_t)KERNBASE;
        size_t npages_allocated = (temp1 - temp2) / PGSIZE;
        size_t i;
        for (i = 0; i < npages; i++) {
                if (i == 0) {
                        //pages[i].pp_ref = 1;
                        pages[i].pp_ref = 0;
                        pages[i].pp_link = NULL;
                }

                else if (i >= npages_basemem && i < (npages_basemem + npages_hole + npages_allocated)) {
                        //pages[i].pp_ref = 1;
                        pages[i].pp_ref = 0;
                        pages[i].pp_link = NULL;

                }
                else {
                        pages[i].pp_ref = 0;
                        pages[i].pp_link = page_free_list;
                        page_free_list = &pages[i];
                }

        }
}


```


```c


mem_init（）
{
    //////////////////////////////////////////////////////////////////////
    // Now that we've allocated the initial kernel data structures, we set
    // up the list of free physical pages. Once we've done so, all further
    // memory management will go through the page_* functions. In
    // particular, we can now map memory using boot_map_region
    // or page_insert
    page_init();
}


```

当 page_init() 初始化完成后，我们来看看 page_alloc() 和 page_free() 的实现

page_alloc() 主要是把一个空闲页从空闲链表上拿下来:
```c
//
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
        // Fill this function in
        struct PageInfo *result = NULL;
        if (page_free_list) {
                result = page_free_list;
                page_free_list = page_free_list->pp_link;
                result->pp_link = NULL;
        }
        else return NULL;

        //if ((alloc_flags & ALLOC_ZERO) && result) {
        if (alloc_flags & ALLOC_ZERO) {
                // zero page
                memset(page2kva(result), '\0', PGSIZE);
        }
        return result;
        //return 0;
}

```
page_free 将一个被释放的页加入到 page_free_list 上来, 可以看到在 page_free 中用 pp_ref 来处理页被多次引用的情况
```c
//
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
        // Fill this function in
        // Hint: You may want to panic if pp->pp_ref is nonzero or
        // pp->pp_link is not NULL.
        if (pp->pp_ref != 0 || pp->pp_link != NULL)
                panic("xjk Double free\n");
        pp->pp_link = page_free_list;
        page_free_list = pp;
}

```
# 特别的当一个页被释放时，如何来判定一个页没有了使用者而被完全释放？？？
在 page_init 时，更合理的做法是将已被占用的页 pp_ref 设置为 1

记住，虽然在 page init 的过程中会用到一些线性地址来计算，但是整个管理结构是针对物理地址的。

# Why can not to use a physical address to access memory directly, when in protected mode?

Once we're in protected mode, there's no way to directly use a linear or physical address. All memory reference are interpreted as virtual addresses and translated by MMU. So, the kernel can't sensibly dereference a physical address. If you cast a phyaddr to a pointer and dereference it, you may be able to load and store to the resulting address, but you probably won't get the memory location you intended. The solution is convert the physical addr to virtual addr, and then use the virtual addr to access.

# How to support converting the physical addr to virtual addr in order to access the physical addr?
the kernel remaps all of physical memory starting from physical address 0 at virtual address 0xf0000000 to read and write memory for which it knows just the physical address.
??????? remap ???????????
究竟是哪种场景
1. 二级页表分配后，需要填到一级，并且需要访问二级页表的表项。这也就是意味着如何去访问二级页表表项 
2. 

# how to handle the reference count of page directory pages and page table pages?
Reference counting(pp_ref)


# 当我们熟悉了页管理后再来看 Exercise 3？？？？
```
(qemu) info pg
VPN range     Entry         Flags        Physical page
[00000-003ff]  PDE[000]     ----A----P
  [00000-000b7]  PTE[000-0b7] --------WP 00000-000b7
  [000b8-000b8]  PTE[0b8]     ---DA---WP 000b8
  [000b9-000ff]  PTE[0b9-0ff] --------WP 000b9-000ff
  [00100-00105]  PTE[100-105] ----A---WP 00100-00105
  [00106-00106]  PTE[106]     --------WP 00106
  [00107-00109]  PTE[107-109] ----A---WP 00107-00109
  [0010a-00110]  PTE[10a-110] --------WP 0010a-00110
  [00111-00111]  PTE[111]     ---DA---WP 00111
  [00112-00112]  PTE[112]     ----A---WP 00112
  [00113-00114]  PTE[113-114] --------WP 00113-00114
  [00115-00115]  PTE[115]     ---DA---WP 00115
  [00116-003ff]  PTE[116-3ff] --------WP 00116-003ff
[f0000-f03ff]  PDE[3c0]     ----A---WP
  [f0000-f00b7]  PTE[000-0b7] --------WP 00000-000b7
  [f00b8-f00b8]  PTE[0b8]     ---DA---WP 000b8
  [f00b9-f00ff]  PTE[0b9-0ff] --------WP 000b9-000ff
  [f0100-f0105]  PTE[100-105] ----A---WP 00100-00105
  [f0106-f0106]  PTE[106]     --------WP 00106
  [f0107-f0109]  PTE[107-109] ----A---WP 00107-00109
  [f010a-f0110]  PTE[10a-110] --------WP 0010a-00110
  [f0111-f0111]  PTE[111]     ---DA---WP 00111
  [f0112-f0112]  PTE[112]     ----A---WP 00112
  [f0113-f0114]  PTE[113-114] --------WP 00113-00114
  [f0115-f0115]  PTE[115]     ---DA---WP 00115
  [f0116-f03ff]  PTE[116-3ff] --------WP 00116-003ff
(qemu) info mem
0000000000000000-0000000000400000 0000000000400000 -r-
00000000f0000000-00000000f0400000 0000000000400000 -rw

```

Exercise 4
## pgdir_walk
pgdir_walk() 以给定的 page directory table 为起点（This requires walking the two-level page table structure），寻找 linear address 'va' 对应的 PTE 并返回 PTE 的指针

# pgdir_walk 中 KADDR 能不能调用？？？
注意一下调用 pgdir_walk 函数时映射表的状态
因为KADDR 是通过 pa + KERNBASE 来计算内核虚拟地址的，这就要求物理地址 0 被映射到 KERNBASE 处。
至少此处的物理地址 pa 是要求已经被在页表中映射过了，并且还满足 pa + KERNBASE 的关系


# 如果我们分配了一个页表物理页，这个时候该如何去访问它呢？
矛盾的地方在于
1. 如果是为了访问一个虚拟地址，那么我们可以先分配物理页，然后通过建立映射来访问。
2. 如果是为了访问一个物理页，那么我们任然需要先建立映射，但是此时针对页表物理页的情况，它就是我们需要访问的，且是建立映射也需要的？？？（其中一种方法就是提前建立一个固定映射）(bootstrap)


```c
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
        // Fill this function in
        pte_t *table_entry = NULL, *table;
        pde_t *pgdir_entry;
        // 1. find the entry in pgdir

        pgdir_entry = &pgdir[PDX(va)];

        // 2. check the entry
        if (*(pgdir_entry) & PTE_P)
        //    1). present
                {
        //        1). find the entry in pt_table, and return pte
                  table = KADDR(PTE_ADDR(*pgdir_entry));
                  table_entry = &table[PTX(va)];
                  return table_entry;

                }
        //    2). not present
        else if (create != 0){
        //        1). page_alloc, increment the ref, clear the page
                struct PageInfo *table_page;
                table_page = page_alloc(ALLOC_ZERO);
                if (table_page == NULL)
                        return NULL;
                table_page->pp_ref++;

                physaddr_t table_phyaddr;
                table_phyaddr = page2pa(table_page);
                table = KADDR(table_phyaddr);
                // table = page2kva(table_page);
                table_entry = &table[PTX(va)];

                *pgdir_entry = table_phyaddr | PTE_P;
                return table_entry;

        }
        else
        {
                return NULL;
        }

        return NULL;
}



```

# 根据上面的分析，特别留意一下关于 256MB 映射是如何建立起来的，特别是在没有页表页的情况下，我们如何保证分配的物理页可以通过线性映射的方法去访问？？？
此处也涉及填页表的问题？？？

## boot_map_region
基于页表 pgdir 将虚拟地址空间 [va, va+size) 映射到物理地址空间 [pa, pa+size) ，相当于填写页表 pgdir 中对应的页表项。
```c
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
        // Fill this function in
        pte_t *table_entry = NULL;
        pde_t *pgdir_entry = NULL;
        for (size_t i = 0; i < size; i = i + PGSIZE) {
                table_entry = pgdir_walk(pgdir, (void *)(va + i), 1);
                pgdir_entry = &pgdir[PDX(va+i)];

                *table_entry = (pa + i) | perm | PTE_P;
                *pgdir_entry |= perm;
        }

}

```

# 因为 boot_map_region 是基于 pgdir_walk 来实现的，所以，上面写的如何访问页表中的项，确实是个需要思考的问题？除非，该页表是在 4MB 空间之内，但是如何让page_alloc 分配该空间内的内存呢？？？

## page_lookup
找到映射到虚拟地址 va 处的物理页，如果需要的话，同时把对应的页表项的地址通过参数传递出来
```c
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
        // Fill this function in

        pte_t *table_entry = NULL;
        struct PageInfo *ret;
        table_entry = pgdir_walk(pgdir, va, 0);
        if (table_entry == NULL) {
                return NULL;
        }
        else if (*table_entry & PTE_P)
        {
                ret = pa2page(PTE_ADDR(*table_entry));
                if (pte_store != NULL)
                        *pte_store = table_entry;
                return ret;

        }
        else return NULL;
        return NULL;
}

```

## page_remove
删除映射到虚拟地址 va 处的映射项，如果可以的话，需要释放该物理页到空闲链表中去。

```c
void
page_remove(pde_t *pgdir, void *va)
{
        // Fill this function in
        pte_t *pte_store;
        struct PageInfo *page = NULL;
        page = page_lookup(pgdir, va, &pte_store);
        if (page == NULL)
                return;
        page_decref(page);
        //*pte_store = 0;
        memset(pte_store, 0, sizeof(pte_t));
        tlb_invalidate(pgdir, va);


}


```

## page_insert
将物理页 pp 映射到虚拟地址 va 处，如果 va 处已经有映射，那么需要删除，即更新为新插入的映射。



```c
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
        // Fill this function in

        pte_t *table_entry;
        pde_t *pgdir_entry;
        pgdir_entry = &pgdir[PDX(va)];
        table_entry = pgdir_walk(pgdir, va, 1);
        if (table_entry == NULL)
                return -E_NO_MEM;
        if (*table_entry & PTE_P) {
                tlb_invalidate(pgdir, va);
        }
        if (PTE_ADDR(*table_entry) != page2pa(pp)) {
                if (*table_entry & PTE_P) {
                        page_remove(pgdir, va);
                }
                pp->pp_ref += 1;
        }
        *table_entry = page2pa(pp) | perm | PTE_P;
        *pgdir_entry |= perm;
        return 0;
}

```

# page_insert 与 boot_map_region 的区别在什么地方？？？
与上面的问题相似，查看这俩函数的实现，对比在调用 pgdir_walk 时传递的第三个参数。
# 问题是 pgdir_walk 的第三个参数在 page_insert 中可以为 0 吗？？？
应该是不行，因为一开始 kern_pgdir 的项都是空的。

# 执行完 mem_init 之后，整个虚拟空间是什么状态？？？
## mem_init
```c
void
mem_init(void)
{
        uint32_t cr0;
        size_t n;

        // Find out how much memory the machine has (npages & npages_basemem).
        i386_detect_memory();

        // Remove this line when you're ready to test this function.
        //panic("mem_init: This function is not finished\n");

        //////////////////////////////////////////////////////////////////////
        // create initial page directory.
        kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
        memset(kern_pgdir, 0, PGSIZE);

        //////////////////////////////////////////////////////////////////////
        // Recursively insert PD in itself as a page table, to form
        // a virtual page table at virtual address UVPT.
        // (For now, you don't have understand the greater purpose of the
        // following line.)

        // Permissions: kernel R, user R
        kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
        //////////////////////////////////////////////////////////////////////
        // Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
        // The kernel uses this array to keep track of physical pages: for
        // each physical page, there is a corresponding struct PageInfo in this
        // array.  'npages' is the number of physical pages in memory.  Use memset
        // to initialize all fields of each struct PageInfo to 0.
        // Your code goes here:
        pages = (struct PageInfo *)boot_alloc(npages*sizeof(struct PageInfo));
        memset(pages, 0, npages*sizeof(struct PageInfo));


        //////////////////////////////////////////////////////////////////////
        // Now that we've allocated the initial kernel data structures, we set
        // up the list of free physical pages. Once we've done so, all further
        // memory management will go through the page_* functions. In
        // particular, we can now map memory using boot_map_region
        // or page_insert
        page_init();

        check_page_free_list(1);
        check_page_alloc();
        check_page();

        //////////////////////////////////////////////////////////////////////
        // Now we set up virtual memory

        //////////////////////////////////////////////////////////////////////
        // Map 'pages' read-only by the user at linear address UPAGES
        // Permissions:
        //    - the new image at UPAGES -- kernel R, user R
        //      (ie. perm = PTE_U | PTE_P)
        //    - pages itself -- kernel RW, user NONE
        // Your code goes here:

        boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);
        //////////////////////////////////////////////////////////////////////
        // Use the physical memory that 'bootstack' refers to as the kernel
        // stack.  The kernel stack grows down from virtual address KSTACKTOP.
        // We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
        // to be the kernel stack, but break this into two pieces:
        //     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
        //     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
        //       the kernel overflows its stack, it will fault rather than
        //       overwrite memory.  Known as a "guard page".
        //     Permissions: kernel RW, user NONE
        // Your code goes here:
        boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);

        //////////////////////////////////////////////////////////////////////
        // Map all of physical memory at KERNBASE.
        // Ie.  the VA range [KERNBASE, 2^32) should map to
        //      the PA range [0, 2^32 - KERNBASE)
        // We might not have 2^32 - KERNBASE bytes of physical memory, but
        // we just set up the mapping anyway.
        // Permissions: kernel RW, user NONE
        // Your code goes here:
        //boot_map_region(kern_pgdir, KERNBASE, 2^32 - KERNBASE, 0, PTE_W);
        //boot_map_region(kern_pgdir, KERNBASE, 2^32 - 1 - KERNBASE, 0, PTE_W);
        boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W);

        // Check that the initial page directory has been set up correctly.
        check_kern_pgdir();

        // Switch from the minimal entry page directory to the full kern_pgdir
        // page table we just created.  Our instruction pointer should be
        // somewhere between KERNBASE and KERNBASE+4MB right now, which is
        // mapped the same way by both page tables.
        //
        // If the machine reboots at this point, you've probably set up your
        // kern_pgdir wrong.
        lcr3(PADDR(kern_pgdir));

        check_page_free_list(0);

        // entry.S set the really important flags in cr0 (including enabling
        // paging).  Here we configure the rest of the flags that we care about.
        cr0 = rcr0();
        cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
        cr0 &= ~(CR0_TS|CR0_EM);
        lcr0(cr0);

        // Some more checks, only possible after kern_pgdir is installed.
        check_page_installed_pgdir();
}


```

# 在 boot_map_region 把 UTOP 以上的空间静态映射到页表中，然后启动该页表之前，是不是需要保证 page_alloc 只能分配 4MB 以内的物理内存以保证 PADDR 和 KADDR 的正确运行？？？
还是不需要，只是用来填表项，而没有实质性的访问


实际上通过 boot_map_region 的调用时机，可以看到，在通过 pgdir_walk 获取到页表表项之后，我们就需要用**虚拟地址访问该表项**，填入要映射的内容。也就是说至少在该阶段，在 pgdir_walk 中通过 page_alloc 分配的物理页确实依赖于 4MB 的范围，否则，无法根据 pgdir_walk 返回的页表项虚拟地址在该阶段去访问所指向的内容。

# 思考 Question ...未完待续

# assert 是如何工作的？

# 基于段的地址变换与 GDT 的关系？？？
# 我们设置 page tables 不是给我们自己用的，而是给 MMU 使用的


